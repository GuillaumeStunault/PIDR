theory Lottery
begin

builtins: hashing, asymmetric-encryption, signing, multiset, revealing-signing

// Creer une paire de clé
rule Creer_pk:
    [ Fr(skA), Fr(skB) ]
    --[Once(), Monnaie(skA,'0'+'1'+'1'+'1',skB,'0'+'1'+'1'+'1','0', '0'+'1'+'1'+'1'+'1'+'1'+'1')]->
    [ !SK(skA,$A), Out(pk(skA)), !SK(skB,$B), Out(pk(skB)), Monnaie(skA,'0'+'1'+'1'+'1',skB,'0'+'1'+'1'+'1','0', '0'+'1'+'1'+'1'+'1'+'1'+'1') ]

// Créer le secret
rule Creer_secret:
	[ Fr(secret) , !SK(skA,A)]
  --> 
  	[ !Secret(secret,skA), Out(<sign(h(secret),skA),A>) ]

rule L_Argent:
  let mise = '1'
  in
  [ Monnaie(skA,xA+mise,skB,xB+mise,e, t) ]
  --[Monnaie(skA,xA,skB,xB,e+mise+mise, t), Once2()]->
  [ Monnaie(skA,xA,skB,xB,e+mise+mise, t), Out(<mise,sign(mise, skA)>), Out(<mise,sign(mise, skB)>)]

rule Init:
  [ In(<mise,sign(mise, skA)>), !SK(skA,$A), In(<mise,sign(mise, skB)>), !SK(skB,$B) ]
  --[Neq(skA,skB),Start(skA,skB)]->
  [ T1('0',skA,skB, mise+mise) ]


rule MatchA:
[ T1('0',skA,skB, mise), !Secret(secretA,skA), !SK(skA,$A), In(<sign(h(secret),skA),$A>) ]
--[Eq(verify(sign(h(secret),skA),h(secretA),pk(skA)),true)]->
[ T2('0',skA,skB,secretA, mise) ]

rule MatchAB:
[ T2('0',skA,skB,secretA, mise), !Secret(secretB,skB), !SK(skB,$B), In(<sign(h(secret),skB),$B>) ]
--[Eq(verify(sign(h(secret),skB),h(secretB),pk(skB)),true)]->
[ T3('0',skA,skB,secretA, secretB, mise) ]

rule WinnerA:
[ T3('0',skA,skB,secretA, secretB, mise), Monnaie(skA,xA,skB,xB,e+mise, t) ]
--[Win(skA), Money(skA,xA+mise), Monnaie(skA,xA+mise,skB,xB,e, t)]->
[ Monnaie(skA,xA+mise,skB,xB,e, t) ]

rule WinnerB:
[ T3('0',skA,skB,secretA, secretB, mise), Monnaie(skA,xA,skB,xB,e+mise, t) ]
--[Win(skB), Money(skB,xB+mise), Monnaie(skA,xA,skB,xB+mise,e, t)]->
[ Monnaie(skA,xA,skB,xB+mise,e, t)]

restriction Equality:
  "All x y #i. Eq(x,y) @#i ==> x = y"

  restriction Inequality:
  "All x #i. Neq(x,x) @ #i ==> F"

restriction Once:
  "All #i #j. Once()@#i & Once()@#j ==> #i = #j"

restriction Once2:
  "All #i #j. Once2()@#i & Once2()@#j ==> #i = #j"

lemma executable:
exists-trace
" Ex J #i. Win(J) @ i "

lemma existe_WinnerA:
exists-trace
"  Ex X Y #i #j. (Win(X)@i & Start(X,Y)@j)" 

lemma existe_WinnerB:
exists-trace
"  Ex X Y #i #j. (Win(Y)@i & Start(X,Y)@j)" 

/*lemma repartition:
exists-trace
"  Ex X Y #i #j #k. (Win(X)@i & Start(X,Y)@j & Money(X,'1'+'1'+'1'+'1')@i & Money(Y,'1'+'1')@k)" 
*/

lemma repartition:
"All skA xA skB xB e t #i. Monnaie(skA,xA,skB,xB,e,t)@#i ==> t+'0'+'0' = e+xA+xB"

end

/* rajouter une restriction sur xA => xa {0,..,6} */