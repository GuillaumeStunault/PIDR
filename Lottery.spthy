theory Lottery
begin

builtins: hashing, asymmetric-encryption, signing, multiset, revealing-signing

// Creer une paire de clé
rule Creer_pk:
    [ Fr(sk) ]
  -->
    [ !SK(sk,$A), Out(pk(sk)), PA(sign(sk,sk),'1'+'1'+'1') ]

// Créer le secret
rule Creer_secret:
	[ Fr(secret) , !SK(skA,A)]
  --> 
  	[ !Secret(secret), Out(<sign(h(secret),skA),A>) ]

/*
rule Depart:
  [  ]
  -->
  [ PA($A,'1'+'1'+'1') ]
*/

rule L_Argent:
  let mise = '1'
  in
  [ PA(J, x + mise), !SK(sk,A) ]
  -->
  [ PA(J, x), Out(sign(mise, sk))]

rule Init:
  [ In(sign(mise, skA)), !SK(skA,$A), In(sign(mise, skB)), !SK(skB,$B) ]
  --[Neq(skA,skB),Start($A,$B)]->
  [ BC(<mise,skA>, <mise,skB>) ]

rule InitBC:
[ BC(<mise,skA>, <mise,skB>) ]
-->
[ W1($A, mise), W1($B,mise) ]

rule InitW:
[ W1(J, mise)]
-->
[ W('0',J,mise)]

rule Win:
[ W('0',$A,mise), W('0',$B,mise) ]
-->
[ T1('0',$A,$B, mise+mise) ]

/*rule envoiBC:
[ m ]
-->
[ BC(m) ]
*/

/*
rule Match:
[ T1('0',A,B, mise), !Secret(secretA), !SK(skA), In(<sign(h(secret),skA),A>) ]
--[Eq(h(secretA), getMessage(revealingSign(h(secret),skA)))]->
[ T2('0',A,B,secretA, mise) ]
*/
rule Match:
[ T1('0',$A,$B, mise), !Secret(secretA), !SK(skA,$A), In(<h(secret),$A>) ]
--[Eq(h(secretA), h(secret))]->
[ T2('0',$A,$B,secretA, mise) ]

rule GetMsg:
[ In(<sign(h(secret),sk),J>), !SK(sk,J) ]
-->
[ Out(<h(secret), J>) ]

/*
rule Match2:
[ T2('0',A,B,secretA, mise), !Secret(secretB), !SK(skB), In(<sign(h(secret),skB),B>) ]
--[Eq(h(secretB), getMessage(revealingSign(h(secret),skB)))]->
[ T3('0',A,B,secretA, secretB, mise) ]
*/
rule Match2:
[ T2('0',$A,$B,secretA, mise), !Secret(secretB), !SK(skB,$B), In(<h(secret),$B>) ]
--[Eq(h(secretB), h(secret))]->
[ T3('0',$A,$B,secretA, secretB, mise) ]

rule Winner:
[ T3('0',$A,$B,secretA, secretB, mise) ]
-->
[ W('epsilon', $A, mise) ]

rule Winner2:
[ T3('0',$A,$B,secretA, secretB, mise) ]
-->
[ W('epsilon', $B, mise) ]

rule Fin:
[ W('epsilon', J, mise), !SK(skJ,J), PA(sign(skJ,skJ),x)]
--[ Win(J) ]->
[ PA(J, x+mise) ]


restriction Equality:
  "All x y #i. Eq(x,y) @#i ==> x = y"

  restriction Inequality:
  "All x #i. Neq(x,x) @ #i ==> F"

lemma executable:
exists-trace
" Ex J #i. Win(J) @ i "

lemma existe_Winner:
exists-trace
"  Ex X Y #i #j. (Win(X)@i & Start(X,Y)@j)" 

lemma existe_Winner2:
exists-trace
"  Ex X Y #i #j. (Win(Y)@i & Start(X,Y)@j)" 

end



