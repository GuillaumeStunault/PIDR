theory Lottery
begin

builtins: hashing, asymmetric-encryption, signing, multiset, revealing-signing

// Creer une paire de clé
rule Creer_pk:
    [ Fr(sk) ]
  -->
    [ !SK(sk,$A), Out(pk(sk)), !PA(sk,'1'+'1'+'1') ]

// Créer le secret
rule Creer_secret:
	[ Fr(secret) , !SK(skA,A)]
  --> 
  	[ !Secret(secret,skA), Out(<sign(h(secret),skA),A>) ]

rule L_Argent:
  let mise = '1'
  in
  [ !PA(sk, x + mise) ]
  --[Money(sk,x)]->
  [ !PM(sk, x), Out(<mise,sign(mise, sk)>)]

rule Init:
  [ In(<mise,sign(mise, skA)>), !SK(skA,$A), In(<mise,sign(mise, skB)>), !SK(skB,$B) ]
  --[Neq(skA,skB),Start(skA,skB)]->
  [ T1('0',skA,skB, mise+mise) ]


rule MatchA:
[ T1('0',skA,skB, mise), !Secret(secretA,skA), !SK(skA,$A), In(<sign(h(secret),skA),$A>) ]
--[Eq(verify(sign(h(secret),skA),h(secretA),pk(skA)),true)]->
[ T2('0',skA,skB,secretA, mise) ]

rule MatchAB:
[ T2('0',skA,skB,secretA, mise), !Secret(secretB,skB), !SK(skB,$B), In(<sign(h(secret),skB),$B>) ]
--[Eq(verify(sign(h(secret),skB),h(secretB),pk(skB)),true)]->
[ T3('0',skA,skB,secretA, secretB, mise) ]

rule WinnerA:
[ T3('0',skA,skB,secretA, secretB, mise) ]
-->
[ W2('epsilon', skA, mise) ]

rule WinnerB:
[ T3('0',skA,skB,secretA, secretB, mise) ]
-->
[ W2('epsilon', skB, mise) ]

rule Fin:
[ W2('epsilon', skJ, mise), !PM(skJ,x)]
--[ Win(skJ), Money(skJ,x+mise) ]->
[ !PA(skJ, x+mise) ]

rule updatePA:
[ !PM(sk,x) ]
-->
[ !PA(sk,x) ]

restriction Equality:
  "All x y #i. Eq(x,y) @#i ==> x = y"

  restriction Inequality:
  "All x #i. Neq(x,x) @ #i ==> F"

restriction Once:
  "All #i #j. Once()@#i & Once()@#j ==> #i = #j"

lemma executable:
exists-trace
" Ex J #i. Win(J) @ i "

lemma existe_WinnerA:
exists-trace
"  Ex X Y #i #j. (Win(X)@i & Start(X,Y)@j)" 

lemma existe_WinnerB:
exists-trace
"  Ex X Y #i #j. (Win(Y)@i & Start(X,Y)@j)" 

lemma repartition:
exists-trace
"  Ex X Y #i #j #k. (Win(X)@i & Start(X,Y)@j & Money(X,'1'+'1'+'1'+'1')@i & Money(Y,'1'+'1')@k)" 



end

