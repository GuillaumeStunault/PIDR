theory Lottery
begin

builtins: hashing, asymmetric-encryption, signing, multiset, revealing-signing

// Creer une paire de clé
rule Creer_pk:
    [ Fr(sk) ]
  -->
    [ !SK(sk), Out(pk(sk)) ]

// Créer le secret
rule Creer_secret:
	[ Fr(secret) ]
  --> 
  	[ !Secret(secret), Out(<sign(h(secret),skA),$A>) ]

rule Depart:
  [  ]
  -->
  [ PA($A,'1'+'1'+'1') ]

rule Argent:
  let mise = '1'
  in
  [ PA(J, x + mise), SK(sk) ]
  -->
  [ PA(J, x), Out(sign(mise, sk))]

rule Init:
  [ In(sign(mise, skA)), !SK(skA), In(sign(mise, skB)), !SK(skB) ]
  --[Neq(skA,skB)]->
  [ BC(<mise,skA>, <mise,skB>) ]

rule InitBC:
[ BC(<mise,skA>, <mise,skB>) ]
-->
[ W(A, mise), W(B,mise) ]

rule Win:
[ W(A,mise), W(B,mise) ]
-->
[ T1('0',A,B, mise+mise) ]

/*rule envoiBC:
[ m ]
-->
[ BC(m) ]
*/

/*
rule Match:
[ T1('0',A,B, mise), !Secret(secretA), !SK(skA), In(<sign(h(secret),skA),A>) ]
--[Eq(h(secretA), getMessage(revealingSign(h(secret),skA)))]->
[ T2('0',A,B,secretA, mise) ]
*/
rule Match:
[ T1('0',A,B, mise), !Secret(secretA), !SK(skA), In(<h(secret),A>) ]
--[Eq(h(secretA), h(secret))]->
[ T2('0',A,B,secretA, mise) ]

rule GetMsg:
[ In(<sign(h(secret),sk),J>), !SK(sk) ]
-->
[ Out(<h(secret), J>) ]

/*
rule Match2:
[ T2('0',A,B,secretA, mise), !Secret(secretB), !SK(skB), In(<sign(h(secret),skB),B>) ]
--[Eq(h(secretB), getMessage(revealingSign(h(secret),skB)))]->
[ T3('0',A,B,secretA, secretB, mise) ]
*/
rule Match2:
[ T2('0',A,B,secretA, mise), !Secret(secretB), !SK(skB), In(<h(secret),B>) ]
--[Eq(h(secretB), h(secret))]->
[ T3('0',A,B,secretA, secretB, mise) ]

rule Winner:
[ T3('0',A,B,secretA, secretB, mise) ]
-->
[ W('epsilon', A, mise) ]

rule Winner2:
[ T3('0',A,B,secretA, secretB, mise) ]
-->
[ W('epsilon', B, mise) ]

rule Fin:
[ W('epsilon', J, mise) ]
-->
[ PA(J, x+mise) ]
end

